/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <bsp_lcd.h>
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include "stm32f429xx.h"
#include "reg_util.h"
#include "ili9341_reg.h"
void SystemClock_Setup(void);
void LTDC_Pin_Init(void);
void LIDC_Init(void);
int main(void)
{
	SystemClock_Setup();
	LTDC_Pin_Init();
	LTDC_Init();
	BSP_LCD_Init();
    /* Loop forever */
	for(;;);
}
void LTDC_Pin_Init(void)
{
	//Enable the periherals clock for GPIO Port involved in LTDC interface
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOAEN_Pos);
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOBEN_Pos);
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOCEN_Pos);
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIODEN_Pos);
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOGEN_Pos);
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOFEN_Pos);
	//Set configuration about alternate function
	for(int i =0;i<total_ltdc_pins;i++)
	{
		REG_SET_VAL(ltdc_io_ports[i]->MODER,2U,0x3U,(ltdc_pins[i]*2U));
		REG_CLR_BIT(ltdc_io_ports[i]->OTYPER,ltdc_pins[i]);
		REG_SET_VAL(ltdc_io_ports[i]->OSPEEDR,2U,0x3U,(ltdc_pins[i]*2U));
		if(ltdc_pins[i]<8)
		{
			REG_SET_VAL(ltdc_io_ports[i]->AFR[0],14U,0xFU,(ltdc_pins[i]*4U));
		}
		else
		{
			REG_SET_VAL(ltdc_io_ports[i]->AFR[1],14U,0xFU,((ltdc_pins[i]%8)*4U));
		}
	}
}
void LTDC_Init(void)
{
	LTDC_TypeDef* pLTDC =LTDC;
	REG_SET_BIT(RCC->APB2ENR,RCC_APB2ENR_LTDCEN_Pos);
	//Cau hinh ma hoa thoi gian dong bo hoa theo chieu ngang
	REG_SET_VAL(pLTDC->SSCR,(BSP_LCD_HSW-1),0xFFFU,LTDC_SSCR_HSW_Pos);
	REG_SET_VAL(pLTDC->BPCR,(BSP_LCD_HSW+BSP_LCD_HBP-1),0xFFFU,LTDC_BPCR_AHBP_Pos);
	REG_SET_VAL(pLTDC->AWCR,(BSP_LCD_HSW+BSP_LCD_HBP+BSP_LCD_ACTIVE_WIDTH_LANDSCAPE-1),0xFFFU,LTDC_AWCR_AAW_Pos);
	uint32_t total_width = BSP_LCD_HSW+BSP_LCD_HBP+BSP_LCD_ACTIVE_WIDTH_LANDSCAPE+BSP_LCD_HFP-1;
	REG_SET_VAL(pLTDC->TWCR,total_width,0xFFFU,LTDC_TWCR_TOTALW_Pos);
	//Cau hinh ma hoa thoi gian dong bo hoa theo chieu doc
	REG_SET_VAL(pLTDC->SSCR,(BSP_LCD_VSW-1),0x7FFU,LTDC_SSCR_VSH_Pos);
	REG_SET_VAL(pLTDC->BPCR,(BSP_LCD_VSW+BSP_LCD_VBP-1),0x7FFU,LTDC_BPCR_AVBP_Pos);
	REG_SET_VAL(pLTDC->AWCR,(BSP_LCD_VSW+BSP_LCD_VBP+BSP_LCD_ACTIVE_HEIGHT_LANDSCAPE-1),0x7FFU,LTDC_AWCR_AAH_Pos);
	uint32_t total_height = BSP_LCD_VSW+BSP_LCD_VBP+BSP_LCD_ACTIVE_HEIGHT_LANDSCAPE+BSP_LCD_VFP-1;
	REG_SET_VAL(pLTDC->TWCR,total_height,0x7FFU,LTDC_TWCR_TOTALH_Pos);
	//Cau hinh nen mau(mau do)
	REG_SET_VAL(pLTDC->BCCR,0xFF0000U,0xFFFFFFU,LTDC_BCCR_BCBLUE_Pos);
	//Dinh dang mac dinh cho hsycn, vsync, ltdc_clk,DE
	//TODO
	//Enable ngoai vi LTDC
	REG_SET_BIT(pLTDC->GCR,LTDC_GCR_LTDCEN_Pos);
}

void SystemClock_Setup(void)
{
	RCC_TypeDef *pRCC = RCC;
	FLASH_TypeDef *pFlash = FLASH;
	PWR_TypeDef *pPWR = PWR;
	//1. Programing Flash wait states
	REG_SET_VAL(pFlash->ACR,0x5U,0xFU,FLASH_ACR_LATENCY_Pos);
	//2. Over Drive Setting
	REG_SET_BIT(pRCC->APB1ENR,RCC_APB1ENR_PWREN_Pos); //Enable clock for PWR register access
	REG_SET_VAL(pPWR->CR,0x3,0x3,PWR_CR_VOS_Pos); //VOS = 0B11
	REG_SET_BIT(pPWR->CR,PWR_CR_ODEN_Pos); // Activate over drive mode
	while(!REG_READ_BIT(pPWR->CSR,PWR_CSR_ODRDY_Pos)); //wait for overdrive ready
	REG_SET_BIT(pPWR->CR,PWR_CR_ODSWEN_Pos);
	//3. Setting up main PPL
	//PLL_M
	REG_SET_VAL(pRCC->PLLCFGR,0x8U,0x3FU,0U); //PLLM
	REG_SET_VAL(pRCC->PLLCFGR,180U,0x1FFU,6U);//PLLN
	REG_SET_VAL(pRCC->PLLCFGR,0x00U,0x3U,16U);//PLLP
	//4. Setting up LCD_CLK using PLLSAI block
	REG_SET_VAL(pRCC->PLLSAICFGR,50U,0x1FFU,RCC_PLLSAICFGR_PLLSAIN_Pos);//PLLSAI_N
	REG_SET_VAL(pRCC->PLLSAICFGR,0x02U,0x7U,RCC_PLLSAICFGR_PLLSAIR_Pos);//PLLSAI_R
	//LCD_CLK = 6.25MHz
	REG_SET_VAL(pRCC->DCKCFGR,0x08U,0x3U,RCC_DCKCFGR_PLLSAIDIVR_Pos);//DIV
	//5. Setting up AHB and APBx clocks
	REG_SET_VAL(pRCC->CFGR,0U,0xFU,RCC_CFGR_HPRE_Pos); //AHB prescaler
	REG_SET_VAL(pRCC->CFGR,0x5U,0x7U,RCC_CFGR_PPRE1_Pos); //APB1 prescaler
	REG_SET_VAL(pRCC->CFGR,0x4U,0x7U,RCC_CFGR_PPRE2_Pos); //APB2 prescaler
	//6. Turn on PLL and wait for PLLCLK ready
	REG_SET_BIT(pRCC->CR,RCC_CR_PLLON_Pos);
	while(!REG_READ_BIT(pRCC->CR,RCC_CR_PLLRDY_Pos));
	//7. Switch PLLCLK as SYSCLK
	REG_SET_VAL(pRCC->CFGR,0x2U,0x3U,RCC_CFGR_SW_Pos);
	while(!REG_READ_VAL(pRCC->CFGR,0x3U,RCC_CFGR_SWS_Pos) == 0x2U);

}
